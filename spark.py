# -*- coding: utf-8 -*-
"""Spark.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VJfyRVzAwv6wL2l2DHTTxUcH6cJkXDT4
"""


from pyspark.sql import SparkSession
from pyspark.sql.functions import regexp_extract, split, explode, avg, count, col
from pyspark.sql.window import Window
from pyspark.sql.functions import row_number, desc

# Initialisation de la session Spark
spark = SparkSession.builder \
    .appName("MovieLens ETL") \
    .master("local[*]") \
    .getOrCreate()

# Charger les fichiers CSV
print("Chargement des fichiers CSV...")  # Titre ajoutée
movies_df = spark.read.option("header", True).csv("movies.csv")
ratings_df = spark.read.option("header", True).csv("ratings.csv")

# Afficher les premières lignes et le schéma des DataFrames
print("Affichage des premières lignes de 'movies_df' et de son schéma :")
movies_df.show(5)
movies_df.printSchema()

print("Affichage des premières lignes de 'ratings_df' et de son schéma :")
ratings_df.show(5)
ratings_df.printSchema()

# Extraire l'année de sortie du film à partir du titre
print("Extraction de l'année de sortie des films...")
movies_df = movies_df.withColumn(
    "year",
    regexp_extract("title", "\\((\\d{4})\\)", 1)
)

# Afficher après l'extraction de l'année
print("Affichage après extraction de l'année :")
movies_df.show(5)

# Séparer les genres en lignes distinctes (explosion des genres)
print("Explosion des genres (un genre par ligne)...")
movies_df = movies_df.withColumn(
    "genre",
    explode(split("genres", "\\|"))
)

# Afficher après l'explosion des genres
movies_df.show(5)

# Calcul des statistiques de ratings : nombre et moyenne des ratings par film
print("Calcul des statistiques de ratings (count, avg)...")
ratings_stats = ratings_df.groupBy("movieId") \
    .agg(
        count("rating").alias("rating_count"),
        avg("rating").alias("rating_avg")
    )

# Afficher les statistiques de ratings
ratings_stats.show(5)

# Jointure entre movies_df et ratings_stats
print("Jointure entre movies_df et ratings_stats...")
final_df = movies_df.join(
    ratings_stats,
    movies_df.movieId == ratings_stats.movieId,
    "inner"
).select(
    movies_df.movieId.alias("movie_id"),
    movies_df.title.alias("movie_name"),
    "year",
    "genre",
    "rating_count",
    "rating_avg"
)

# Afficher les résultats après la jointure
print("Affichage des résultats après jointure :")
final_df.show(10)

# Sauvegarder le dataset final dans un fichier Parquet
print("Sauvegarde des résultats dans le fichier 'silver_movielens' (Parquet)...")
final_df.write.mode("overwrite").parquet("silver_movielens")

# Charger à nouveau le dataset silver (Parquet)
print("Rechargement du dataset 'silver_movielens' depuis le Parquet...")
silver_df = spark.read.parquet("silver_movielens")

# Créer une vue temporaire pour exécuter des requêtes SQL
print("Création d'une vue temporaire pour exécuter des requêtes SQL...")
silver_df.createOrReplaceTempView("movies")

# Requête SQL : Meilleur film par année
print("Meilleur film par année (SQL) :")
spark.sql("""
SELECT year, movie_name, rating_avg
FROM movies
ORDER BY year, rating_avg DESC
""").show(10)

# Requête SQL : Meilleur film par genre
print("Meilleur film par genre (SQL) :")
spark.sql("""
SELECT genre, movie_name, rating_avg
FROM movies
ORDER BY genre, rating_avg DESC
""").show(10)

# Requête SQL : Meilleur film "Action" par année
print("Meilleur film 'Action' par année (SQL) :")
spark.sql("""
SELECT year, movie_name, rating_avg
FROM movies
WHERE genre = 'Action'
ORDER BY year, rating_avg DESC
""").show(10)

# Requête SQL : Meilleur film "Romance" par année
print("Meilleur film 'Romance' par année (SQL) :")
spark.sql("""
SELECT year, movie_name, rating_avg
FROM movies
WHERE genre = 'Romance'
ORDER BY year, rating_avg DESC
""").show(10)

# Fenêtres pour les classements
print("Définition des fenêtres pour le classement des films...")
window_year = Window.partitionBy("year").orderBy(desc("rating_avg"))
window_genre = Window.partitionBy("genre").orderBy(desc("rating_avg"))
window_action_year = Window.partitionBy("year").orderBy(desc("rating_avg"))
window_romance_year = Window.partitionBy("year").orderBy(desc("rating_avg"))

# Meilleur film par année
print("Meilleur film par année (Fenêtre) :")
best_movie_per_year = silver_df \
    .withColumn("rank", row_number().over(window_year)) \
    .filter(col("rank") == 1) \
    .select("year", "movie_name", "rating_avg", "rating_count")

best_movie_per_year.show(10)

# Meilleur film par genre
print("Meilleur film par genre (Fenêtre) :")
best_movie_per_genre = silver_df \
    .withColumn("rank", row_number().over(window_genre)) \
    .filter(col("rank") == 1) \
    .select("genre", "movie_name", "rating_avg", "rating_count")

best_movie_per_genre.show(10)

# Filtrer pour le genre "Action"
print("Filtrage pour le genre 'Action'...")
action_df = silver_df.filter(silver_df.genre == "Action")

# Meilleur film "Action" par année
print("Meilleur film 'Action' par année (Fenêtre) :")
best_action_movie_per_year = action_df \
    .withColumn("rank", row_number().over(window_action_year)) \
    .filter(col("rank") == 1) \
    .select("year", "movie_name", "rating_avg", "rating_count")

best_action_movie_per_year.show(10)

# Filtrer pour le genre "Romance"
print("Filtrage pour le genre 'Romance'...")
romance_df = silver_df.filter(silver_df.genre == "Romance")

# Meilleur film "Romance" par année
print("Meilleur film 'Romance' par année (Fenêtre) :")
best_romance_movie_per_year = romance_df \
    .withColumn("rank", row_number().over(window_romance_year)) \
    .filter(col("rank") == 1) \
    .select("year", "movie_name", "rating_avg", "rating_count")

best_romance_movie_per_year.show(10)